---
title: Basestack Feature Flags - React & NextJS Reference
description: Integration with React helps and facilitates the process of testing and developing features in production and other environments.
tags: Basestack, Feature Flags, React, SDK, Hooks, Components, State, Async, Flags, Flag, Initialize, Methods, Reference, Examples
---

# React SDK Reference

Integration with React or NextJS helps and facilitates the process of testing and developing features in production and other environments.

## Getting started

    For React and Next.js, we chose not to create a separate SDK, as it would
    essentially act as a wrapper for our JavaScript SDK. Instead, we’ll show you
    how to fully utilize the JavaScript SDK within a React or Next.js project.
    This approach ensures you can access all the features of a React SDK without
    needing to install additional packages. One key advantage is that you retain
    complete control over the code, allowing you to extend its functionality with
    custom implementations.

### Examples

- [react-js](https://github.com/basestack-co/examples/tree/main/feature-flags/react-js)
- [next-js](https://github.com/basestack-co/examples/tree/main/feature-flags/next-js)

### Install

First, let's install some packages!

```sh copy npm2yarn
npm i @basestack/flags-js
```

### Create a new folder called `feature-flags` in the `src/libs` directory

Inside the `feature-flags` folder, create the following files and folders:

- index.tsx
- server.ts
- `hooks` folder
  - useFlag.tsx
  - useFlags.tsx
  - index.ts

```tsx copy filename="src/libs/feature-flags/index.tsx"
"use client";

import React, { createContext, useEffect, useMemo, useState } from "react";
import { FlagsSDK, Flag, SDKConfig } from "@basestack/flags-react";

interface ContextState {
  client: FlagsSDK;
  isInitialized: boolean;
  flags: Flag[];
  error?: Error;
}

interface ProviderProps {
  children: React.ReactNode;
  config: SDKConfig;
  onSuccessfulInit?: (success: boolean) => void;
}

export const createFlagsClient = (config: SDKConfig) => {
  return new FlagsSDK({
    baseURL: config.baseURL,
    projectKey: config.projectKey,
    environmentKey: config.environmentKey,
  });
};

export const FeatureFlagsContext = createContext<ContextState | undefined>(
  undefined,
);

const FeatureFlagsProvider: React.FC<ProviderProps> = ({
  children,
  config,
  onSuccessfulInit,
}) => {
  const [state, setState] = useState<Omit<ContextState, "client">>({
    isInitialized: false,
    flags: [],
  });
  const client = useMemo(() => createFlagsClient(config), [config]);
  const value = useMemo(() => ({ ...state, client }), [state, client]);

  useEffect(() => {
    let isMounted = true;

    const initializeFlags = async () => {
      try {
        const response = await client.getAllFlags();

        if (isMounted) {
          setState((prev) => ({
            ...prev,
            flags: response.flags ?? [],
            isInitialized: true,
          }));
          onSuccessfulInit?.(true);
        }
      } catch (error) {
        if (isMounted) {
          setState((prev) => ({
            ...prev,
            error: error as Error,
            isInitialized: true,
          }));
          onSuccessfulInit?.(false);
        }
      }
    };

    initializeFlags();

    return () => {
      isMounted = false;
    };
  }, [client, onSuccessfulInit]);

  return (
    <FeatureFlagsContext.Provider value={value}>
      {children}
    </FeatureFlagsContext.Provider>
  );
};

export default FeatureFlagsProvider;
```

```ts copy filename="src/libs/feature-flags/server.ts"
import { FlagsSDK, SDKConfig } from "@basestack/flags-react";

export class ServerFlagsSDK {
  private static instance: FlagsSDK;
  private static config: SDKConfig = {
    baseURL: process.env.NEXT_PUBLIC_FEATURE_FLAGS_BASE_URL,
    projectKey: process.env.NEXT_PUBLIC_FEATURE_FLAGS_PROJECT_KEY!,
    environmentKey: process.env.NEXT_PUBLIC_FEATURE_FLAGS_ENVIRONMENT_KEY!,
  };

  public static getInstance(): FlagsSDK {
    if (!ServerFlagsSDK.instance) {
      ServerFlagsSDK.instance = new FlagsSDK(ServerFlagsSDK.config);
    }
    return ServerFlagsSDK.instance;
  }
}
```

```tsx copy filename="src/libs/feature-flags/hooks/useFlag.tsx"
"use client";

import { useContext, useEffect, useState, useMemo } from "react";
// Feature Flags Context
import { FeatureFlagsContext } from "@/libs/feature-flags";
import { Flag } from "@basestack/flags-react";

export const useFlag = <P = Record<string, unknown>,>(slug: string) => {
  const context = useContext(FeatureFlagsContext);
  const [flag, setFlag] = useState<Flag | null>(null);
  const [error, setError] = useState<Error | null>(null);

  if (!context) {
    throw new Error("useFlag must be used within a FeatureFlagsContext");
  }

  useEffect(() => {
    let isMounted = true;

    const fetchFlag = async () => {
      if (!context.isInitialized || !context.client) return;

      try {
        if (context.flags.length > 0) {
          const foundFlag = context.flags.find((f) => f.slug === slug);
          if (foundFlag) {
            isMounted && setFlag(foundFlag);
          } else {
            isMounted && setError(new Error(`Flag "${slug}" not found`));
          }
        } else {
          const fetchedFlag = await context.client.getFlag(slug);
          isMounted && setFlag(fetchedFlag);
        }
      } catch (err) {
        isMounted &&
          setError(err instanceof Error ? err : new Error(String(err)));
      }
    };

    fetchFlag();

    return () => {
      isMounted = false;
    };
  }, [context.isInitialized, context.client, context.flags, slug]);

  return useMemo(
    () => ({
      ...flag,
      error,
      isInitialized: context.isInitialized,
      payload: (flag?.payload as P) ?? null,
    }),
    [error, context.isInitialized, flag],
  );
};
```

```tsx copy filename="src/libs/feature-flags/hooks/useFlags.tsx"
"use client";

import { useContext, useEffect, useState, useMemo } from "react";
// Feature Flags Context
import { FeatureFlagsContext } from "@/libs/feature-flags";
import { Flag } from "@basestack/flags-react";

interface FlagsState {
  flags: Flag[];
}

interface UseFlagsResult extends FlagsState {
  error: Error | null;
  isInitialized: boolean;
}

export const useFlags = (): UseFlagsResult => {
  const context = useContext(FeatureFlagsContext);
  const [{ flags }, setFlags] = useState<FlagsState>({ flags: [] });
  const [error, setError] = useState<Error | null>(null);

  if (!context) {
    throw new Error("useFlags must be used within a FeatureFlagsContext");
  }

  useEffect(() => {
    if (!context.isInitialized || !context.client) {
      return;
    }

    if (context.flags.length > 0) {
      setFlags({ flags: context.flags });
      return;
    }

    let isMounted = true;

    context.client
      .getAllFlags()
      .then((result) => {
        if (isMounted) {
          setFlags(result);
        }
      })
      .catch((err) => {
        if (isMounted) {
          setError(err instanceof Error ? err : new Error(String(err)));
        }
      });

    return () => {
      isMounted = false;
    };
  }, [context.isInitialized, context.client, context.flags.length]);

  return useMemo(
    () => ({
      error,
      isInitialized: context.isInitialized,
      flags,
    }),
    [flags, context.isInitialized, error],
  );
};
```

```ts copy filename="src/libs/feature-flags/hooks/index.ts"
export * from "./useFlag";
export * from "./useFlags";
```

### Add the `FeatureFlagsProvider` to your App

The example below demonstrates how to add the `FeatureFlagsProvider` to your Next.js app using the App Router. It can also be used in the `_app.tsx` file or a React SPA app.

```tsx copy filename="src/app/layout.tsx"
import React from "react";
import "./globals.css";
// Feature Flags
import FeatureFlagsProvider from "@/libs/feature-flags";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>
        <FeatureFlagsProvider
          config={{
            baseURL: process.env.NEXT_PUBLIC_FEATURE_FLAGS_BASE_URL,
            projectKey: process.env.NEXT_PUBLIC_FEATURE_FLAGS_PROJECT_KEY!,
            environmentKey:
              process.env.NEXT_PUBLIC_FEATURE_FLAGS_ENVIRONMENT_KEY!,
          }}
        >
          {children}
        </FeatureFlagsProvider>
      </body>
    </html>
  );
}
```

Your app is now fully equipped to take advantage of feature flags and other powerful functionalities offered by Basestack. To maximize the potential of Basestack, refer to the instructions provided in the supported hooks and components documentation.

### Usage

#### In a React Component

```tsx copy filename="src/app/page.tsx"
"use client";

// Feature Flags Hooks
import { useFlag, useFlags } from "@/libs/feature-flags/hooks";

export default function Home() {
  const count = useFlag<{ text: string }>("count");
  const data = useFlags();

  return (
    <div>
      <main>
        {count.enabled && (
          <div>
            <a>
              {!count.enabled
                ? "Count is not enabled"
                : `${count?.payload?.text} 0`}
            </a>
          </div>
        )}

        <h3>All the available flags</h3>
        <ul>
          {data.flags.map((flag, index) => {
            return (
              <li
                key={index}
              >{`Slug: ${flag.slug} Enabled: ${flag.enabled}`}</li>
            );
          })}
        </ul>
      </main>
    </div>
  );
}
```

#### In a API Route Handler

```ts copy filename="src/app/api/count/route.ts"
import { ServerFlagsSDK } from "@/libs/feature-flags/server";

export async function GET() {
  const flagsClient = ServerFlagsSDK.getInstance();

  const flag = await flagsClient.getFlag("count");
  const data = await flagsClient.getAllFlags();

  return Response.json({ data, flag });
}
```


## Initialisation options

For details regarding the initialization options of @basestack/flags-js, please refer to the documentation related to the [Javascript SDK](/feature-flags/sdks/javascript#initialisation-options).

## Troubleshooting

### Why are my components rendering twice?

It's normal. Check if your App/Component is wrapped inside [React.StrictMode ↗](https://react.dev/reference/react/StrictMode?ref=basestack.co). The purpose of `React.StrictMode` is to help identify potential problems in your application by highlighting some unsafe practices or potential bugs during development.

When you wrap a component in `React.StrictMode`, it can cause some components to be rendered twice. This is expected behavior and is not specific to your code. Rendering twice is intentional and done by React on purpose.

```js copy filename="main.ts"
const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(
  <React.StrictMode>
    <FlagsProvider
      sdk={sdk}
      onSuccessfulInit={() => console.log("Successful Init FlagsJS SDK")}
    >
      <App />
    </FlagsProvider>
  </React.StrictMode>,
);
```
